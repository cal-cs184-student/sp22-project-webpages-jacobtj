<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <style>
    body {
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
    }

    h1,
    h2,
    h3,
    h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
  <title>CS 184 Mesh Editor</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

  <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
  <h1 align="middle">Project 2: Mesh Editor</h1>
  <h2 align="middle">Jacob Jiang</h2>

  <br><br>

  <div>

    <h2 align="middle">Overview</h2>
    <p> 
        In this project, I implemented de Casteljau's algorithm for evaluating polynomials into a Bezier curve,
        then extended that to generate Bezier surfaces using the same algoritm for a grid of vectors. After that,
        I implemented smooth shading on a mesh by computing area-weighted vector normals. I then implemented more 
        mesh operations, this time flipping and splitting edges on a mesh by manipulating all of the 
        mesh pointers. Finally, I combined flipping and splitting edges to perform loop subdivision to upsample
        the mesh to a high-resolution. Through this project, I learned how Bezier surfaces are created and represented 
        using the interpolation of vectors, how smooth shading is implemented through weighting vector normals,
        and how mesh's are upsampled to increase detail and resolution using edge operations. It was interesting to 
        observe how resolution could be increased simply by performing splits and filps on a mesh. Plus, I really 
        liked the cow shown below. 
    </p>

    <br />
    <div align="middle">
        <table style="width=100%">
            <tr>
                <td>
                    <img src="images/cow.png" align="middle" width="400px" />
                    <figcaption align="middle"></figcaption>
                </td>
            </tr>
        </table>
        <br />
    </div>

    <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

    <h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

    <p>
        de Casteljau's algorithm evaluates polynomials into a Bezier curve by using linear interpolation with a set of
        control points and a t term. I implemented it by completing a function that completed one step of this algorithm
        by performing linear interpolation on the given points to find a weighted average between each two points, creating
        a new set with one less point. After continually calling the function, eventually, the algorithm would complete, 
        leaving us with one point that lies on the Bezier curve. The whole curve could then be generated by modifying the
        t parameter. Below is a diagram demonstrating each step of the algorithm on an example set of points. 
    </p>

    <div align="middle">
        <table style="width=100%">
            <tr>
                <td>
                    <img src="images/step0.png" align="middle" width="400px" />
                    <figcaption align="middle">Level 0</figcaption>
                </td>
                <td>
                    <img src="images/step1.png" align="middle" width="400px" />
                    <figcaption align="middle">Level 1</figcaption>
                </td>
            </tr>
            <br />
            <tr>
                <td>
                    <img src="images/step2.png" align="middle" width="400px" />
                    <figcaption align="middle">Level 2</figcaption>
                </td>
                <td>
                    <img src="images/step3.png" align="middle" width="400px" />
                    <figcaption align="middle">Level 3</figcaption>
                </td>
            </tr>
            <br />
            <tr>
                <td>
                    <img src="images/step4.png" align="middle" width="400px" />
                    <figcaption align="middle">Level 4</figcaption>
                </td>
                <td>
                    <img src="images/step5.png" align="middle" width="400px" />
                    <figcaption align="middle">Level 5</figcaption>
                </td>
            </tr>
        </table>
        <br />
        <img src="images/movedcontrolpoints.png" align="middle" width="400px" />
        <figcaption align="middle">Bezier Curve with Modified Control Points and t-value</figcaption>
    </div>

    <br />
    <h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>

    <p>
        I extended de Casteljau's algorithm to Bezier surfaces by using the same logic that was used for Bezier curves, 
        running the algorithm for each set of 3D vectors in control points, the n x n grid of vectors. I then stored each
        result in a results vector. Finally, I ran the algorithm once more on this results vector to return the the final
        interpolated vector. Below is a diagram demonstrating a bezier surface created through this process.
    </p>

    <div align="middle">
        <br />
        <img src="images/teapot.png" align="middle" width="400px" />
        <figcaption align="middle">A teapot!</figcaption>
    </div>

    <br />
    <br />
    <h2 align="middle">Section II: Sampling</h2>

    <h3 align="middle">Part 3: Average normals for half-edge meshes</h3>

    <p>
        I implemented the area-weighted vertex normals by finding two vectors that make up each face (that includes the vertex) and finding their cross product.
        After finding all these cross products, I took the sum and normalized the result vector to return the area weighted vertex normal. Below is a comparison
        between the original flat shading and Phong shading, using the area-weighted vertex normals that I implemented.
    </p>

    <div align="middle">
        <table style="width=100%">
            <tr>
                <td>
                    <img src="images/flat.png" align="middle" width="400px" />
                    <figcaption align="middle">Flat Shading</figcaption>
                </td>
                <td>
                    <img src="images/phong.png" align="middle" width="400px" />
                    <figcaption align="middle">Phong Shading</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <br />
    <h3 align="middle">Part 4: Half-edge flip</h3>

    <p>
        I implemented the edge flip operation by reassigning mesh pointers within the 2 triangle faces that share the edge being flipped. 
        I first reassigned all the pointers for all 6 halfedges so they would correspond with the result of a flipped edge. I then 
        reassigned the faces, vertices, and edges to make sure they all still pointed to a valid halfedge. I had some problems initially
        with flipped edges disappearing and causing holes in the mesh, but after using count_for() to compare the pointers for each mesh 
        element individually before and after the reassignment, I was able to fix the bugs. Below is a demonstration of the result of 
        flipping edges.
    </p>

    <div align="middle">
        <br />
        <table style="width=100%">
            <tr>
                <td>
                    <img src="images/flip1.png" align="middle" width="400px" />
                    <figcaption align="middle">A few flips...</figcaption>
                </td>
                <td>
                    <img src="images/flip2.png" align="middle" width="400px" />
                    <figcaption align="middle">Many more flips...</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <br />
    <h3 align="middle">Part 5: Half-edge split</h3>

    <p>
        I implemented the edge split operation by creating new mesh elements and reassigning values from the existing mesh. Since splitting 
        the edge was essentially turning 2 triangle faces into 4 faces, I reassigned the exisiting mesh values so that they would correspond 
        with 2 of the faces in the resultant mesh and then added 3 new edges, 6 new halfedges, 2 new faces, and 1 new vertex (whose position 
        was assigned to the midpoint of the edge being split) to create the other 2 new faces. I first created all these new mesh elements
        and assigned their pointers and then proceeded to reassign the exisiting mesh pointers so that it all matched up with the result of
        a split. The debugging process for this part was much quicker as I just ran through all my pointer reassignments while cross referencing 
        a diagram of a mesh split and was able to create a working implementation. Below are some diagrams showing the result of some edge 
        split and flip operations.
    </p>

    <div align="middle">
        <img src="images/beforesplit.png" align="middle" width="400px" />
        <figcaption align="middle">Before Splitting</figcaption>
        <table style="width=100%">
            <tr>
                <td>
                    <img src="images/aftersplit.png" align="middle" width="400px" />
                    <figcaption align="middle">A few splits later...</figcaption>
                </td>
                <td>
                    <img src="images/aftersplitandflip.png" align="middle" width="400px" />
                    <figcaption align="middle">Many splits and flips later...</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <br />
    <h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>

    <p>
        I implemented loop subdivision using the steps described in the spec. I first computed new positions of 
        the vertices in the original mesh using the listed and stored those in an attribute called newPosition(). 
        I then computed the new positions of the new vertices that would be created after performing edge split 
        operations on each edge by using the equation listed and stored those in the newPosition() attribute of
        each edge. After computing those newpositions, I subdivided the mesh by calling the edge split function
        implemented in part 5 on each edge and then set the new position for the vertex created by splitting
        using the newPosition() in each edge. Then, I flipped each edge that connected a new vertex with and old 
        vertex using the edge flip function I implemented in part 4. Finally, I set each vertex's position to the
        new position stored in newPosition(). 

        There were many bugs in my initial implementation of this part. I used print statements to look at the
        new positions that were being set for each vertex before and after performing subdivision and printed
        many mesh pointers to verify that the correct number of pointers were being set. I also printed all of the 
        neighbor positions that I was using to compute the newPosition parameter. After trying many different 
        implementations and going through this debugging process for many many hours, I found that I was accidentally
        setting half of the original edge that was split by the edge split function as a new edge, causing the
        shape of my mesh to be distorted. I also eventually found out that because of the way my pointers were set up,
        my calcualtion of the neighbor positions was simply adding the vertex position multiple times instead of accessing
        the neighbor positions. Below are some diagrams showing a cube object going through a few iterations of loop 
        subdivision.

    </p>

    <div align="middle">
        <img src="images/cube1.png" align="middle" width="400px" />
        <figcaption align="middle">Original Cube</figcaption>
        <table style="width=100%">
            <tr>
                <td>
                    <img src="images/cube2.png" align="middle" width="400px" />
                    <figcaption align="middle">1 iteration</figcaption>
                </td>
                <td>
                    <img src="images/cube3.png" align="middle" width="400px" />
                    <figcaption align="middle">2 iterations</figcaption>
                </td>
            </tr>
            <tr>
                <td>
                    <img src="images/cube4.png" align="middle" width="400px" />
                    <figcaption align="middle">3 iterations</figcaption>
                </td>
                <td>
                    <img src="images/cube5.png" align="middle" width="400px" />
                    <figcaption align="middle">4 iterations</figcaption>
                </td>
            </tr>
        </table>
    </div>

    <p>
        I noted that after loop subdivision, the edges of the cube became rounded into a more sphere-like object,
        as seen in the cube above after a few iterations of loop subdivision. This likely occurs because the 
        cube is composed of not many edges and thus does not have a very defined structure, so splitting those edges 
        and repositioning them based on the neighboring positions results in the edges blending into a sphere-like
        object.
        
        Below, you can see that by pre-splitting some of the edges of the original cube, we are better able to preserve 
        the edges of the cube and the overall cube structure through subdivision, as the structure of the cube is composed
        of more edges and is thus more defined.
    </p>

    <div align="middle">
        <img src="images/cub1.png" align="middle" width="400px" />
        <figcaption align="middle">Pre-processed Cube</figcaption>
        <table style="width=100%">
            <tr>
                <td>
                    <img src="images/cub2.png" align="middle" width="400px" />
                    <figcaption align="middle">1 iteration</figcaption>
                </td>
                <td>
                    <img src="images/cub3.png" align="middle" width="400px" />
                    <figcaption align="middle">2 iterations</figcaption>
                </td>
            </tr>
        </table>
    </div>

</body>

</html>